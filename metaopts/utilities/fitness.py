"""Fitness related utility functions."""

import tensorflow as tf
from .print import print_function_trace


def create_fitness_function(
        model,
        loss,
        x,
        y,
        batch_size
    ):
    """
    Creates a fitness function which evaluates the model's fitness with a random batch.

    Args:
        model: `tf.keras.Model` - Neural network model.
        loss: `tf.keras.losses.Loss` - Loss function.
        x: `tf.Tensor` - Input data.
        y: `tf.Tensor` - Target data.
        batch_size: `int` - Number of samples per fitness calculation.

    Notes:

    * The created fitness function has no input parameters because it is linked to the model.
    * You must change the model weights first and then call the fitness function for evaluation.
    * Converting the training data to `tf.Tensor` allows graph execution.
    """

    # Shape of network output
    output_shape = (batch_size,) + model.output_shape[1:]

    # Batch randomization index limit
    random_limit = x.shape[0] - batch_size + 1

    # Variables for the fitness function
    batch_start = tf.Variable(0, dtype=tf.int32)
    batch_end = tf.Variable(0, dtype=tf.int32)
    predictions = tf.Variable(tf.zeros(output_shape), dtype=tf.float32)

    @tf.function
    def fitness_fn():

        # Print debug information
        print_function_trace('fitness_fn')

        # Randomize batch
        batch_start.assign(tf.random.uniform(shape=(), minval=0, maxval=random_limit, dtype=tf.int32))
        batch_end.assign(batch_start + batch_size)

        # Make batch prediction
        predictions.assign(model(x[batch_start:batch_end]))

        # Return loss value
        return loss(y[batch_start:batch_end], predictions)

    return fitness_fn


def update_individual_fitness(
        model_weights,
        model_fitness_fn,
        fitness_values,
        population,
        individual_index,
        deviation=0.1
    ):
    """
    Updates the fitness value of an individual in the population.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        fitness_values: `tf.Variable` - Fitness values of the population.
        population: `list` of `tf.Variable` - List of population weights.
        individual_index: `int` - Index of the individual in the population.
        deviation: `float` - Standard deviation of the normal distribution used to generate random weights.
    
    Notes:

    * The function replaces invalid weights with zeros.
    * The function assigns random weights to the individual if the fitness value is invalid.
    * Invalid weights and fitness values inlude `nan`, `inf` and `-inf`.
    """

    # Print debug information
    print_function_trace('update_individual_fitness')

    # Loop over weights
    for mw, p in zip(model_weights, population):

        # Replace invalid weights with random values
        p[individual_index].assign(tf.where(tf.math.is_finite(p[individual_index]),
                                            p[individual_index],
                                            tf.random.normal(p[individual_index].shape, 0, deviation)))

        # Assign test weights to model
        mw.assign(p[individual_index])
    
    # Update fitness value
    fitness_values[individual_index].assign(model_fitness_fn())

    # If fitness value is invalid
    if tf.logical_not(tf.math.is_finite(fitness_values[individual_index])):
        
        # Loop over weights
        for mw, p in zip(model_weights, population):

            # Assign random weights to individual
            p[individual_index].assign(tf.random.normal(p[individual_index].shape, 0, deviation))

            # Assign test weights to model
            mw.assign(p[individual_index])
        
        # Update fitness value
        fitness_values[individual_index].assign(model_fitness_fn())


def update_population_fitness(
        model_weights,
        model_fitness_fn,
        fitness_values,
        population,
        population_size,
        deviation=0.1
    ):
    """
    Updates the fitness value of each individual in the population.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        fitness_values: `tf.Variable` - Fitness values of the population.
        population: `list` of `tf.Variable` - List of population weights.
        population_size: `int` - Number of individuals in the population.
        deviation: `float` - Standard deviation of the normal distribution used to generate random weights.
    
    Notes:

    * The function replaces invalid weights with zeros.
    * The function assigns random weights to the individual if the fitness value is invalid.
    * Invalid weights and fitness values inlude `nan`, `inf` and `-inf`.
    """

    # Print debug information
    print_function_trace('update_population_fitness')

    # Loop over individuals
    for i in tf.range(population_size):

        # Update individual fitness
        update_individual_fitness(
            model_weights,
            model_fitness_fn,
            fitness_values,
            population,
            i,
            deviation
        )


update_individual_fitness = tf.function(update_individual_fitness)
update_population_fitness = tf.function(update_population_fitness)
