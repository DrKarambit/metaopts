import tensorflow as tf
import metaopts.utilities as mou


def metaheuristic_template(
        model_weights,
        model_fitness_fn,
        generation_limit,
        fitness_limit,
        population_size,
        transfer_learning=False,
        fitness_log_frequency=-1,
        best_individual_save_frequency=-1
    ):
    """
    This is a recommendation template for implementing a metaheuristic algorithm.

    Implementation of YOUR ALGORITHM.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        generation_limit: `int` - Maximum number of generations.
        fitness_limit: `float` - Fitness value threshold.
        population_size: `int` - Number of vultures in the population.
        transfer_learning: `bool` - Whether to use transfer learning.
        fitness_log_frequency: `int` - Frequency of logging fitness values to the log file. If set to -1, no logging is performed.
        best_individual_save_frequency: `int` - Frequency of saving the best individual to a pickle file. If set to -1, no saving is performed.
    
    Notes:

    * YOUR NOTES GO HERE

    Reference:

    * YOUR REFERENCE GOES HERE
    """
    
    @tf.function
    def do_calculations():
        mou.print_function_trace('do_calculations')
        pass

    def do_other_calculations():
        pass

    # Create a population using create_population
    # The population consists of multiple individuals
    # The shape of each trainable tf.Variable is expanded to match the population size
    # Keep in mind that in a tf.function you can't index the population list so you have to iterate over it (sometimes by using zip as well)
    population = mou.create_population(
        model_weights,
        population_size,
        transfer_learning
    )

    # Create fitness values as a rank-1 tensor
    fitness_values = tf.zeros(population_size, dtype=tf.float32)

    # Implement your algorithm here which modifies the population and the fitness values
    # There are several utility functions that you can use:

    # When the algorithm starts you can notifiy the user using print_algo_start
    algo_name = 'Metaheuristic Template'
    mou.print_algo_start(algo_name)

    # Initialize the generation counter
    gen = tf.Variable(0, dtype=tf.int32)

    # You can use a while loop to iterate over the generations
    while tf.reduce_min(fitness_values) > fitness_limit and gen <= generation_limit:

        # You can call nested functions related to your algorithm
        # Try using tf.function as often as possible to speed up the execution
        do_calculations()
        do_other_calculations()

        # You can update the fitness values of the whole population using update_population_fitness
        # model_weights, model_fitness_fn, fitness_values, population, population_size
        mou.update_population_fitness(
            model_weights,
            model_fitness_fn,
            fitness_values,
            population,
            population_size
        )

        # You can print the best fitness value found in each generation using print_training_status
        mou.print_training_status(
            generation=int(gen),
            generation_limit=int(generation_limit),
            best_fitness_value=float(tf.reduce_min(fitness_values))
        )

        # You can log the changes of the best fitness value found in each generation using log_fitness_value
        if fitness_log_frequency > 0:
            mou.log_fitness_value(
                fitness_value=float(tf.reduce_min(fitness_values)),
                log_file_name='{0} fitness'.format(algo_name),
                max_cache_size=fitness_log_frequency
            )

        # You can save the best individual in each generation using save_individual
        if best_individual_save_frequency > 0 and gen % best_individual_save_frequency == 0:
            mou.save_individual(
                population=population,
                individual_index=tf.argmin(fitness_values),
                file_path='{0} weights'.format(algo_name)
            )

        # Increment the generation counter
        gen.assign_add(1)


    # When the algorithm ends you can notifiy the user using print_algo_end
    mou.print_algo_end(algo_name)

    # You can apply the best individual to the model using apply_best_solution
    mou.apply_best_solution(
        model_weights,
        model_fitness_fn,
        fitness_values,
        population,
        population_size
    )
