import tensorflow as tf
from metaopts.utilities import *


def metaheuristic_template(
        model_weights,
        model_fitness_fn,
        generation_limit,
        fitness_limit,
        population_size,
        transfer_learning=False,
        log_fitness=False
    ):
    """
    This is a recommendation template for implementing a metaheuristic algorithm.

    Implementation of YOUR ALGORITHM.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        generation_limit: `int` - Maximum number of generations.
        fitness_limit: `float` - Fitness value threshold.
        population_size: `int` - Number of vultures in the population.
        transfer_learning: `bool` - Whether to use transfer learning.
    
    Notes:

    * YOUR NOTES GO HERE

    Reference:

    * YOUR REFERENCE GOES HERE
    """
    
    @tf.function
    def do_calculations():
        print_function_trace('do_calculations')
        pass

    def do_other_calculations():
        pass

    # Create a population using create_population
    # The population consists of multiple individuals
    # The shape of each trainable tf.Variable is expanded to match the population size
    # Keep in mind that in a tf.function you can't index the population list so you have to iterate over it (sometimes by using zip as well)
    population = create_population(model_weights, population_size, transfer_learning)

    # Create fitness values as a rank-1 tensor
    fitness_values = tf.zeros(population_size, dtype=tf.float32)

    # Implement your algorithm here which modifies the population and the fitness values
    # There are several utility functions that you can use:

    # When the algorithm starts you can notifiy the user using print_algo_start
    algo_name = 'Metaheuristic Template'
    print_algo_start(algo_name)

    # Initialize the generation counter
    gen = tf.Variable(0, dtype=tf.int32)

    # You can use a while loop to iterate over the generations
    while gen <= generation_limit and tf.reduce_min(fitness_values) > fitness_limit:

        # You can call nested functions related to your algorithm
        # Try using tf.function as often as possible to speed up the execution
        do_calculations()
        do_other_calculations()

        # You can update the fitness values of the whole population using update_population_fitness
        update_population_fitness(model_weights, model_fitness_fn, fitness_values, population, population_size)

        # You can log the changes of the best fitness value found in each generation using log_fitness_value
        if log_fitness:
            log_fitness_value(gen, tf.reduce_min(fitness_values))

        # Increment the generation counter
        gen.assign_add(1)

    # When the algorithm ends you can notifiy the user using print_algo_end
    print_algo_end(algo_name)

    # You can apply the best individual to the model using apply_best_solution
    apply_best_solution(model_weights, model_fitness_fn, fitness_values, population, population_size)
