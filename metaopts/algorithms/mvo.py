"""Multi-Verse Optimizer."""

import tensorflow as tf
import metaopts.utilities as mou


def mvo(
        model_weights,
        model_fitness_fn,
        generation_limit,
        fitness_limit,
        population_size,
        transfer_learning=False,
        fitness_log_frequency=-1,
        best_individual_save_frequency=-1,
        min=0.2,
        max=1.0,
        p=6.0,
        lower_bound=-1.0,
        upper_bound=1.0
    ):
    """
    Implementation of the Multi-Verse Optimizer algorithm.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        generation_limit: `int` - Maximum number of generations.
        fitness_limit: `float` - Fitness value threshold.
        population_size: `int` - Number of individuals in the population.
        transfer_learning: `bool` - Whether to use transfer learning.
        fitness_log_frequency: `int` - Frequency of logging fitness values to the log file. If set to -1, no logging is performed.
        best_individual_save_frequency: `int` - Frequency of saving the best individual to a pickle file. If set to -1, no saving is performed.
        min: `float` - Minimum value in WEP calculation.
        max: `float` - Maximum value in WEP calculation.
        p: `float` - Exploitation accuracy in TDR calculation.
        lower_bound: `float` - Lower bound in wormhole simulation.
        upper_bound: `float` - Upper bound in wormhole simulation.
    
    Notes:

    * The source code is based on the pseudocode and the equations provided in the paper.
    
    Reference:

    * Mirjalili, Seyedali & Mirjalili, Seyed & Hatamlou, Abdolreza. (2015).
    Multi-Verse Optimizer: a nature-inspired algorithm for global optimization.
    Neural Computing and Applications. 27. 10.1007/s00521-015-1870-7.
    """

    @tf.function
    def update_best_universe():
        mou.print_function_trace('update_best_universe')
        best_index = tf.argmin(fitness_values)
        for u, bu in zip(U, best_universe):
            bu.assign(u[best_index])

    @tf.function
    def update_NI():
        mou.print_function_trace('update_NI')
        reversed = tf.reduce_sum(fitness_values) / fitness_values
        NI.assign(reversed / tf.reduce_sum(reversed))

    @tf.function
    def update_WEP():
        mou.print_function_trace('update_WEP')
        WEP.assign(min_const + gen*((max_const-min_const) / L))

    @tf.function
    def update_TDR():
        mou.print_function_trace('update_TDR')
        TDR.assign(1 - (tf.pow(gen, 1/p_const) / tf.pow(L, 1/p_const)))

    @tf.function
    def black_hole_white_hole_simulation():
        mou.print_function_trace('black_hole_white_hole_simulation')
        for u in U:
            shape = tf.shape(u)
            r1 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            NIUi = tf.reshape(tf.repeat(NI, tf.reduce_prod(shape[1:])), shape)
            white_hole_indices = tf.reshape(tf.random.categorical([tf.math.log(NI)], tf.size(u), dtype=tf.int32), shape)
            for i in tf.range(n):
                white_hole_universe = tf.repeat([u[i]], n, axis=0)
                white_hole_condition = tf.logical_and(r1 < NIUi, white_hole_indices == i)
                u.assign(tf.where(white_hole_condition, white_hole_universe, u))

    @tf.function
    def wormhole_simulation():
        mou.print_function_trace('wormhole_simulation')
        for u, bu in zip(U, best_universe):
            shape = tf.shape(u)
            r2 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            r3 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            r4 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            wormhole_1 = bu + TDR*(ub_const-lb_const)*r4 + lb_const
            wormhole_2 = bu - TDR*(ub_const-lb_const)*r4 + lb_const
            wormhole_universe = tf.where(r3 < 0.5, wormhole_1, wormhole_2)
            u.assign(tf.where(r2 < WEP, wormhole_universe, u))

    # Number of universes (candidate solutions)
    n = tf.constant(population_size, dtype=tf.int32)

    # Create random universes (U)
    U = mou.create_population(
        model_weights=model_weights,
        population_size=n,
        transfer_learning=transfer_learning
    )
    fitness_values = tf.Variable(tf.zeros(n, dtype=tf.float32))

    # Initialize WEP, TDR, and Best_universe
    WEP = tf.Variable(0.0, dtype=tf.float32)
    TDR = tf.Variable(0.0, dtype=tf.float32)
    best_universe = [tf.Variable(tf.zeros_like(weights), dtype=tf.float32) for weights in model_weights]

    # NI=Normalize the inflation rate (fitnesses) of the universes
    NI = tf.Variable(fitness_values, dtype=tf.float32)

    # Initialize other pseudo-code variables
    L = tf.constant(generation_limit, dtype=tf.float32)
    min_const = tf.constant(min, dtype=tf.float32)
    max_const = tf.constant(max, dtype=tf.float32)
    p_const = tf.constant(p, dtype=tf.float32)
    lb_const = tf.constant(lower_bound, dtype=tf.float32)
    ub_const = tf.constant(upper_bound, dtype=tf.float32)
    best_fitness = tf.Variable(0.0, dtype=tf.float32)
    gen = tf.Variable(0.0, dtype=tf.float32)

    # Print debug information
    algo_name = 'Multi-Verse Optimizer'
    mou.print_algo_start(algo_name)

    # while the end criterion is not satisfied
    while gen <= L:
        
        # Evaluate the fitness of all universes
        mou.update_population_fitness(
            model_weights=model_weights,
            model_fitness_fn=model_fitness_fn,
            fitness_values=fitness_values,
            population=U,
            population_size=n
        )
        
        # Update Best_universe and NI
        update_best_universe()
        update_NI()

        # Update best fitness
        best_fitness.assign(tf.reduce_min(fitness_values))

        # Log fitness
        if fitness_log_frequency > 0:
            mou.log_fitness_value(
                fitness_value=float(best_fitness),
                log_file_name='{0} fitness'.format(algo_name),
                max_cache_size=fitness_log_frequency
            )

        # Save best individual
        if best_individual_save_frequency > 0 and gen % best_individual_save_frequency == 0:
            mou.save_individual(
                population=U,
                individual_index=tf.argmin(fitness_values),
                file_path='{0} weights'.format(algo_name)
            )

        # Print training information
        mou.print_training_status(
            generation=int(gen),
            generation_limit=int(L),
            best_fitness_value=float(best_fitness)
        )

        # Additional stopping condition
        if best_fitness < fitness_limit:
            break

        # Update WEP and TDR
        update_WEP()
        update_TDR()

        # Efficient black hole and white hole simulation
        black_hole_white_hole_simulation()

        # Efficient wormhole simulation
        wormhole_simulation()

        gen.assign_add(1)


    # Print debug information
    mou.print_algo_end(algo_name)

    # Apply best solution to the model
    mou.apply_best_solution(
        model_weights=model_weights,
        model_fitness_fn=model_fitness_fn,
        fitness_values=fitness_values,
        population=U,
        population_size=n
    )

    # Log fitness
    if fitness_log_frequency > 0:
        mou.log_fitness_value(
            fitness_value=float(tf.reduce_min(fitness_values)),
            log_file_name='{0} fitness'.format(algo_name),
            max_cache_size=fitness_log_frequency,
            force_file_write=True
        )

    # Save best individual
    if best_individual_save_frequency > 0:
        mou.save_individual(
            population=U,
            individual_index=tf.argmin(fitness_values),
            file_path='{0} weights'.format(algo_name)
        )
