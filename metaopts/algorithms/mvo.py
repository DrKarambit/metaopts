import tensorflow as tf
from metaopts.utilities import *


def mvo(
        model_weights,
        model_fitness_fn,
        generation_limit,
        fitness_limit,
        population_size,
        transfer_learning=False,
        log_fitness=False,
        min=0.2,
        max=1.0,
        p=6.0,
        lower_bound=-1.0,
        upper_bound=1.0
    ):
    """
    Implementation of the Multi-Verse Optimizer algorithm.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        generation_limit: `int` - Maximum number of generations.
        fitness_limit: `float` - Fitness value threshold.
        population_size: `int` - Number of individuals in the population.
        transfer_learning: `bool` - Whether to use transfer learning.
        min: `float` - Minimum value in WEP calculation.
        max: `float` - Maximum value in WEP calculation.
        p: `float` - Exploitation accuracy in TDR calculation.
        lower_bound: `float` - Lower bound in wormhole simulation.
        upper_bound: `float` - Upper bound in wormhole simulation.
    
    Notes:

    * The source code is based on the pseudocode and the equations provided in the paper.
    
    Reference:

    * Mirjalili, Seyedali & Mirjalili, Seyed & Hatamlou, Abdolreza. (2015).
    Multi-Verse Optimizer: a nature-inspired algorithm for global optimization.
    Neural Computing and Applications. 27. 10.1007/s00521-015-1870-7.
    """

    @tf.function
    def update_best_universe():
        print_function_trace('update_best_universe')
        best_index = tf.argmin(fitness_values)
        for u, bu in zip(U, best_universe):
            bu.assign(u[best_index])

    @tf.function
    def update_NI():
        print_function_trace('update_NI')
        reversed = tf.reduce_sum(fitness_values) / fitness_values
        NI.assign(reversed / tf.reduce_sum(reversed))

    @tf.function
    def update_WEP():
        print_function_trace('update_WEP')
        WEP.assign(min_const + gen * ((max_const - min_const) / L))

    @tf.function
    def update_TDR():
        print_function_trace('update_TDR')
        TDR.assign(1 - (tf.pow(gen, 1/p_const) / tf.pow(L, 1/p_const)))

    @tf.function
    def black_hole_white_hole_simulation():
        print_function_trace('black_hole_white_hole_simulation')
        for u in U:
            shape = tf.shape(u)
            r1 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            NIUi = tf.reshape(tf.repeat(NI, tf.reduce_prod(shape[1:])), shape)
            white_hole_indices = tf.reshape(tf.random.categorical([tf.math.log(NI)], tf.size(u), dtype=tf.int32), shape)
            for i in tf.range(n):
                white_hole_universe = tf.repeat([u[i]], n, axis=0)
                white_hole_condition = tf.logical_and(r1 < NIUi, white_hole_indices == i)
                u.assign(tf.where(white_hole_condition, white_hole_universe, u))

    @tf.function
    def wormhole_simulation():
        print_function_trace('wormhole_simulation')
        for u, bu in zip(U, best_universe):
            shape = tf.shape(u)
            r2 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            r3 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            r4 = tf.random.uniform(shape, 0, 1, dtype=tf.float32)
            wormhole_1 = bu + TDR * (ub_const - lb_const) * r4 + lb_const
            wormhole_2 = bu - TDR * (ub_const - lb_const) * r4 + lb_const
            wormhole_universe = tf.where(r3 < 0.5, wormhole_1, wormhole_2)
            u.assign(tf.where(r2 < WEP, wormhole_universe, u))

    # Number of universes (candidate solutions)
    n = tf.constant(population_size, dtype=tf.int32)

    # Create random universes (U)
    U = create_population(model_weights, n, transfer_learning)
    fitness_values = tf.Variable(tf.zeros(n, dtype=tf.float32))

    # Initialize WEP, TDR, and Best_universe
    WEP = tf.Variable(0.0, dtype=tf.float32)
    TDR = tf.Variable(0.0, dtype=tf.float32)
    best_universe = [tf.Variable(tf.zeros_like(weights), dtype=tf.float32) for weights in model_weights]

    # NI=Normalize the inflation rate (fitnesses) of the universes
    NI = tf.Variable(fitness_values, dtype=tf.float32)

    # Initialize other pseudo-code variables
    L = tf.constant(generation_limit, dtype=tf.float32)

    min_const = tf.constant(min, dtype=tf.float32)
    max_const = tf.constant(max, dtype=tf.float32)
    p_const = tf.constant(p, dtype=tf.float32)
    lb_const = tf.constant(lower_bound, dtype=tf.float32)
    ub_const = tf.constant(upper_bound, dtype=tf.float32)

    best_fitness = tf.Variable(0, dtype=tf.float32)
    gen = tf.Variable(0, dtype=tf.float32)

    # Print debug information
    algo_name = 'Multi-Verse Optimizer'
    print_algo_start(algo_name)

    # while the end criterion is not satisfied
    while gen <= L:
        
        # Evaluate the fitness of all universes
        update_population_fitness(model_weights, model_fitness_fn, fitness_values, U, n)
        
        # Update Best_universe and NI
        update_best_universe()
        update_NI()

        # Update best fitness
        best_fitness.assign(tf.reduce_min(fitness_values))

        # Log fitness
        if log_fitness:
            log_fitness_value(float(best_fitness), '{0} fitness'.format(algo_name))

        # Print training information
        print_training_status(int(gen), int(L), float(best_fitness))

        # Additional stopping condition
        if best_fitness < fitness_limit:
            break

        # Update WEP and TDR
        update_WEP()
        update_TDR()

        # Efficient black hole and white hole simulation
        black_hole_white_hole_simulation()

        # Efficient wormhole simulation
        wormhole_simulation()

        gen.assign_add(1)

    # Print debug information
    print_algo_end(algo_name)

    # Apply best solution to the model
    apply_best_solution(model_weights, model_fitness_fn, fitness_values, U, n)

    # Log fitness
    if log_fitness:
        log_fitness_value(float(tf.reduce_min(fitness_values)), '{0} fitness'.format(algo_name), True)
