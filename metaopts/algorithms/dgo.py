import tensorflow as tf
from metaopts.utilities import *


def dgo(
        model_weights,
        model_fitness_fn,
        generation_limit,
        fitness_limit,
        population_size,
        transfer_learning=False,
        fitness_log_frequency=-1,
        throw_count=3
    ):
    """
    Implementation of the Darts Game Optimizer algorithm.

    Args:
        model_weights: `list` of `tf.Variable` - List of model weights.
        model_fitness_fn: `tf.function` - Fitness function generated by `metaopts.create_fitness`.
        generation_limit: `int` - Maximum number of generations.
        fitness_limit: `float` - Fitness value threshold.
        population_size: `int` - Number of individuals in the population.
        transfer_learning: `bool` - Whether to use transfer learning.
        fitness_log_frequency: `int` - Frequency of logging fitness values to the log file. If set to -1, no logging is performed.
        throw_count: `int` - Number of throws per each player.
    
    Notes:

    * The source code is based on the pseudocode and the equations provided in the paper.
    * The throwing mechanism is not covered in the paper, so it is a custom implementation.

    Reference:

    * Dehghani, Mohammad & Montazeri, Zeinab & Givi, Hadi & Guerrero, Josep & Dhiman, Gaurav. (2020).
    Darts Game Optimizer: A New Optimization Technique Based on Darts Game.
    International Journal of Intelligent Engineering and Systems. 13. 286-294. 10.22266/ijies2020.1031.26.
    """
    
    @tf.function
    def eq_2():
        print_function_trace('eq_2')
        F_best.assign(tf.reduce_min(F))
    
    @tf.function
    def eq_3():
        print_function_trace('eq_3')
        best_index = tf.argmin(F)
        for xb, x in zip(X_best, X):
            xb.assign(x[best_index])

    @tf.function
    def eq_4():
        print_function_trace('eq_4')
        F_worst.assign(tf.reduce_max(F))
    
    @tf.function
    def eq_5():
        print_function_trace('eq_5')
        worst_index = tf.argmax(F)
        for xw, x in zip(X_worst, X):
            xw.assign(x[worst_index])
    
    @tf.function
    def eq_6():
        print_function_trace('eq_6')
        Fn.assign(tf.abs((F - F_worst) / tf.reduce_sum(F - F_worst)))
    
    @tf.function
    def eq_7():
        print_function_trace('eq_7')
        P.assign(tf.abs(Fn / tf.reduce_max(Fn)))
    
    @tf.function
    def eq_8():
        print_function_trace('eq_8')
        C.assign(tf.cast(tf.round(82 * (1 - P)), dtype=tf.int32))
    
    @tf.function
    def eq_11():
        print_function_trace('eq_11')
        Sn.assign(tf.cast(tf.reduce_sum(S, axis=1) / 180, dtype=tf.float32))
    
    @tf.function
    def eq_12():
        print_function_trace('eq_12')
        for x, xb in zip(X, X_best):
            rand = tf.random.uniform(x.shape, 0, 1, dtype=tf.float32)
            Sn_shape = tf.concat([[N], tf.ones(tf.rank(x)-1, dtype=tf.int32)], axis=0)
            x.assign(x + rand * (xb - 3 * tf.reshape(Sn, Sn_shape) * x))

    @tf.function
    def simulate_throws():
        print_function_trace('simulate_throws')
        rand = tf.random.uniform((N, throw_count), 0, 1, dtype=tf.float32)
        for i in tf.range(N):
            for j in tf.range(throw_count):
                if rand[i, j] < P[i]:
                    throw_start.assign(0)
                    throw_end.assign(tf.reduce_max([1, C[i]]))
                    throw_offset.assign(0)
                else:
                    throw_start.assign(tf.reduce_min([81, C[i]]))
                    throw_end.assign(82)
                    throw_offset.assign(C[i] - 1)
                SCi = ordered_areas[throw_start:throw_end]
                S[i, j].assign(tf.random.categorical(tf.math.log([SCi]), 1, dtype=tf.int32)[0][0] + throw_offset)
        S.assign(tf.gather(ordered_scores, S))

    def create_dartboard():

        single_scores = tf.range(20, dtype=tf.int32) + 1
        double_scores = (tf.range(20, dtype=tf.int32) + 1) * 2
        triple_scores = (tf.range(20, dtype=tf.int32) + 1) * 3
        outer_bull_score = tf.constant([25], dtype=tf.int32)
        inner_bull_score = tf.constant([50], dtype=tf.int32)

        double_ring_area = tf.constant([202.8962], dtype=tf.float32)
        outer_single_ring_area = tf.constant([932.0041], dtype=tf.float32)
        triple_ring_area = tf.constant([98.5954], dtype=tf.float32)
        inner_single_ring_area = tf.constant([351.0058], dtype=tf.float32)
        outer_bull_area = tf.constant([677.5708], dtype=tf.float32)
        inner_bull_area = tf.constant([126.6769], dtype=tf.float32)

        scores = tf.concat([
            double_scores, 
            single_scores, 
            triple_scores, 
            single_scores, 
            outer_bull_score, 
            inner_bull_score
        ], axis=0)

        areas = tf.concat([
            tf.repeat(double_ring_area, 20),
            tf.repeat(outer_single_ring_area, 20),
            tf.repeat(triple_ring_area, 20),
            tf.repeat(inner_single_ring_area, 20),
            outer_bull_area,
            inner_bull_area
        ], axis=0)

        sorted_indices = tf.argsort(scores, direction='DESCENDING')

        ordered_scores = tf.gather(scores, sorted_indices)
        ordered_areas = tf.gather(areas, sorted_indices)

        return ordered_scores, ordered_areas

    # N is the number of players
    N = tf.constant(population_size, dtype=tf.int32)

    # Creating the initial population of players
    X = create_population(model_weights, N, transfer_learning)

    # Fitness values of the population
    F = tf.Variable(tf.zeros(N, dtype=tf.float32))
    update_population_fitness(model_weights, model_fitness_fn, F, X, N)

    # Initialize other pseudo-code variables
    ordered_scores, ordered_areas = create_dartboard()
    throw_count = tf.constant(throw_count, dtype=tf.int32)
    X_best = [tf.Variable(tf.zeros_like(weights, dtype=tf.float32)) for weights in model_weights]
    F_best = tf.Variable(0.0, dtype=tf.float32)
    X_worst = [tf.Variable(tf.zeros_like(weights, dtype=tf.float32)) for weights in model_weights]
    F_worst = tf.Variable(0.0, dtype=tf.float32)
    Fn = tf.Variable(tf.zeros(N, dtype=tf.float32))
    P = tf.Variable(tf.zeros(N, dtype=tf.float32))
    C = tf.Variable(tf.zeros(N, dtype=tf.int32))
    S = tf.Variable(tf.zeros((N, throw_count), dtype=tf.int32))
    Sn = tf.Variable(tf.zeros(N, dtype=tf.float32))
    throw_start = tf.Variable(0, dtype=tf.int32)
    throw_end = tf.Variable(0, dtype=tf.int32)
    throw_offset = tf.Variable(0, dtype=tf.int32)

    best_fitness = tf.Variable(tf.reduce_min(F), dtype=tf.float32)
    gen = tf.Variable(0, dtype=tf.float32)

    # Print debug information
    algo_name = 'Darts Game Optimizer'
    print_algo_start(algo_name)

    # Checking the stop conditions
    while best_fitness > fitness_limit and gen <= generation_limit:
        
        # Print training information
        print_training_status(int(gen), int(generation_limit), float(best_fitness))

        # Updating Fbest, Xbest, Fworst, and Xworst using (2) to (5)
        eq_2()
        eq_3()
        eq_4()
        eq_5()

        # Updating Fn and Pi using (6) and (7)
        eq_6()
        eq_7()

        # Calculating sni using (8) to (11)
        eq_8()
        simulate_throws()
        eq_11()

        # Updating Xi using (12)
        eq_12()

        # Updating fitness values.
        update_population_fitness(model_weights, model_fitness_fn, F, X, N)
        best_fitness.assign(tf.reduce_min(F))

        # Log fitness
        if fitness_log_frequency > 0:
            log_fitness_value(float(best_fitness), '{0} fitness'.format(algo_name), fitness_log_frequency)

        gen.assign_add(1)

    # Print debug information
    print_algo_end(algo_name)

    # Apply best solution to the model
    apply_best_solution(model_weights, model_fitness_fn, F, X, N)

    # Log fitness
    if fitness_log_frequency > 0:
        log_fitness_value(float(tf.reduce_min(F)), '{0} fitness'.format(algo_name), fitness_log_frequency, True)
